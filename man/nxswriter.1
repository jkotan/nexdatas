.\" Man page generated from reStructuredText.
.
.TH "NXSWRITER" "1" "May 03, 2016" "2.1" "NXSDataWriter"
.SH NAME
nxswriter \- nxswriter Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
Authors: Jan Kotanski, Eugen Wintersberger, Halil Pasic
.SH INTRODUCTION
.sp
NXSDataWriter is a Tango server which allows to store NeXuS Data in H5 files.
.sp
The server provides storing data from other Tango devices, various databases
as well as passed by a user client via JSON strings.
.nf
Source code: \fI\%https://github.com/nexdatas/writer\fP
Web page: \fI\%http://www.desy.de/~jkotan/nxswriter\fP
.fi
.sp
.SH INSTALLATION
.sp
Install the dependencies:
.INDENT 0.0
.INDENT 3.5
pni\-libraries, PyTango, numpy
.UNINDENT
.UNINDENT
.SS From sources
.sp
Download the latest NexDaTaS version from
.INDENT 0.0
.INDENT 3.5
\fI\%https://github.com/nexdatas/writer\fP
.UNINDENT
.UNINDENT
.sp
Extract sources and run
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ python setup.py install
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Debian packages
.sp
Debian Jessie (and Wheezy) packages can be found in the HDRI repository.
.sp
To install the debian packages, add the PGP repository key
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo su
$ wget \-q \-O \- http://repos.pni\-hdri.de/debian_repo.pub.gpg | apt\-key add \-
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
and then download the corresponding source list
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cd /etc/apt/sources.list.d
$ wget http://repos.pni\-hdri.de/jessie\-pni\-hdri.list
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Finally,
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ apt\-get update
$ apt\-get install python\-nxswriter
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To instal other NexDaTaS packages
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ apt\-get install python\-nxstools nxsconfigserver\-db python\-nxsconfigserver nxsconfigtool
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
and
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ apt\-get install python\-nxsrecselector nxselector python\-sardana\-nxsrecorder
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
for Component Selector and Sardana related packages.
.SH INSTALLATION FROM SOURCES
.sp
Extract sources and run
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ python setup.py install
.ft P
.fi
.UNINDENT
.UNINDENT
.SH GENERAL OVERVIEW
.sp
All operations carried out on a beamline are orchestrated by the control client (CC),
a software operated by the beamline\-scientist and/or a user. Although the term client
suggests that it is only a minor component aside from all the hardware control servers,
databases, and whatever software is running on a beamline it is responsible for all
the other components and tells them what to do at which point in time. In terms of
an orchestra the CC is the director which tells each group of instruments or individual
artist what to do at a certain point in time.
.sp
It is important to understand the role of the CC in the entire software system on a beamline
as it determines who is responsible for certain operations. The CC might be a simple
single script running on the control PC which can is configured by the user before start
or it might be a whole application of its own like SPEC or ONLINE. Historically it is
the job of the CC to write the data recorded during the experiment (this is true at least
for low rate data\-sources). However, with the appearance of complex data formats
like Nexus the IO code becomes more complex.
.SH PROJECT GOALS
.sp
The aim of this project is to implement a Tango server that manages data IO
for synchrotron (and maybe neutron) beamlines. The server should satisfy the
following requirements
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
remove responsibility for data IO from the beamline control client
.IP \(bu 2
provide a simple configuration mechanism via NXDL
.IP \(bu 2
.INDENT 2.0
.TP
.B read data from the following sources without client interaction
# SQL databases (MySQL, Postgres, Oracle, DB2, ...)
# other TANGO servers
# JSON records (important for the interaction with the client and SARDANA)
.UNINDENT
.IP \(bu 2
the first implementation of the server will be written in Python
.IP \(bu 2
.INDENT 2.0
.TP
.B the communication model of the first implementation will be strictly synchronous
(future version most probably will support other communication models too)
.UNINDENT
.IP \(bu 2
.INDENT 2.0
.TP
.B the control client software has full control over the behavior of the server
via TANGO commands
.UNINDENT
.IP \(bu 2
only low data\-rate sources will be handled directly by the server. High data\-rate
.IP \(bu 2
.INDENT 2.0
.TP
.B sources will write their data independently and additional software will add this data
to the Nexus file produced by the server once the experiment is finished.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The server should make it easy to implement control clients which write Nexus files
as the entire Nexus logic is kept in the server. Clients only produce NXDL configurations
or use third party tools for this job. The first Python implementation of
this server will serve as a proof of concept.
.sp
In order to describe various data sources the NXDL standard has been extended by XML tags listed
below. Thus, <strategy /> and <datasource /> can be situated inside <field/> or <attribute/> tags.
The other ones are nested inside <datasource/> tag.
.SH THE <STRATEGY> TAG
.sp
The \fBstrategy\fP tag defines when and in which way the data is stored.
.sp
An example of usage:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<field name="energy" type="NX_FLOAT" units="GeV" >
  <strategy mode="STEP" trigger="trigger1" />
  <datasource type="CLIENT">
   <record name="counter_1"/>
  </datasource>
</field>
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B The tag can have the following attributes:
.INDENT 7.0
.IP \(bu 2
.INDENT 2.0
.TP
.B \fBmode\fP specifies when the data is fetched, i.e.
.INDENT 7.0
.IP \(bu 2
\fIINIT\fP during opening a new entry
.IP \(bu 2
\fISTEP\fP when the record() command is performed
.IP \(bu 2
\fIFINAL\fP at the time of closing the entry
.IP \(bu 2
\fIPOSTRUN\fP during post\-processing stage
.UNINDENT
.UNINDENT
.IP \(bu 2
\fBtrigger\fP stands for the name of the related trigger in asynchronous STEP mode (optional)
.IP \(bu 2
.INDENT 2.0
.TP
.B \fBgrows\fP selects which a field dimension grows of in the STEP mode. The default growing
dimension is the first one, i.e. grows=1 (optional)
.UNINDENT
.IP \(bu 2
.INDENT 2.0
.TP
.B \fBcompression\fP specifies if data is compressed (optional)
.INDENT 7.0
.IP \(bu 2
\fItrue\fP data going to be compressed
.IP \(bu 2
\fIfalse\fP data stored without compression (default)
.UNINDENT
.UNINDENT
.IP \(bu 2
.INDENT 2.0
.TP
.B \fBrate\fP compression rate (optional)
.INDENT 7.0
.IP \(bu 2
from 0 to 9
.UNINDENT
.UNINDENT
.IP \(bu 2
.INDENT 2.0
.TP
.B \fBshuffle\fP compression shuffle (optional)
.INDENT 7.0
.IP \(bu 2
true shuffle enabled (default)
.IP \(bu 2
false shuffle disabled
.UNINDENT
.UNINDENT
.IP \(bu 2
.INDENT 2.0
.TP
.B \fBcanfail\fP specifies if during reading data exception should be thrown (optional)
.INDENT 7.0
.IP \(bu 2
false on error exception is raised (default)
.IP \(bu 2
.INDENT 2.0
.TP
.B true on error warning info is printed and the record is filled by a maximum value
for the record type
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The \fBcontent\fP of the strategy tags is an label describing data merged into the H5 file by
a post\-processing program.
.sp
Another example of usage:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<field name="energy" type="NX_FLOAT" units="GeV" >
  <strategy mode="POSTRUN" >
    http://haso.desy.de:/data/energy.dat
  </strategy>
</field>
.ft P
.fi
.UNINDENT
.UNINDENT
.SH THE <DATASOURCE> TAG
.sp
The \fBdatasource\fP tag specifies a type of the used data sources. They can be one of built types,
i.e. CLIENT, TANGO, DB, PYEVAL or external ones \-\- defined in external python package
and registered via JSON data.
.sp
The <datasouce> tag acquires the following attributes:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
.INDENT 2.0
.TP
.B \fBtype\fP related to a type of data source with possible values:
.INDENT 7.0
.IP \(bu 2
\fICLIENT\fP for communication with client via JSON strings
.IP \(bu 2
\fITANGO\fP for taking data from Tango servers
.IP \(bu 2
\fIDB\fP for fetching data from databases
.IP \(bu 2
\fIPYEVAL\fP for evaluating data from other data sources by python script
.IP \(bu 2
\fIother type name\fP of data source which has been registered via JSON data.
.UNINDENT
.UNINDENT
.IP \(bu 2
\fBname\fP datasource name (optional)
.UNINDENT
.UNINDENT
.UNINDENT
.SH CLIENT DATASOURCE
.sp
The \fBCLIENT\fP datasource allows to read data from client JSON strings. It should contain
a <record /> tag. An example of usage:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<datasource type="CLIENT" name="exp_c01">
  <record name="counter_1"/>
</datasource>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS <record>
.sp
The \fBrecord\fP tag defines the fetched data by its name. It has an attrbute
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fBname\fP which for the CLIENT data source type denotes a name of the data in the JSON string
.UNINDENT
.UNINDENT
.UNINDENT
.sp
An example of usage:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<record name="Position"/>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS TANGO datasource
.sp
The \fBTANGO\fP datasource allows to read data from other TANGO devices. It should contain <device/>
and <record/> tags. An example of usage:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<datasource type="TANGO">
  <device hostname="haso.desy.de" member="attribute" name="p09/motor/exp.01"
          port="10000" encoding="LIMA_VIDEO_IMAGE"/>
  <record name="Position"/>
</datasource>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS <device>
.sp
The \fBdevice\fP tag describes the Tango device which is used to get the data.
It has the following attributes:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fBname\fP corresponding to a name of the Tango device
.IP \(bu 2
.INDENT 2.0
.TP
.B \fBmember\fP defining a type of the class member, i.e.
.INDENT 7.0
.IP \(bu 2
\fIattribute\fP an attribute to read
.IP \(bu 2
\fIcommand\fP a result of a command to take
.IP \(bu 2
\fIproperty\fP a property to read
.UNINDENT
.UNINDENT
.IP \(bu 2
\fBhostname\fP a name of the host with the Tango device server (optional)
.IP \(bu 2
\fBport\fP a port number related to the Tango device server (optional)
.IP \(bu 2
\fBencoding\fP a label defining a required decoder for DevEncoded? data (optional)
.IP \(bu 2
\fIgroup\fP tango group name (optional)
.UNINDENT
.UNINDENT
.UNINDENT
.sp
If group attribute is defined data of the same group is read simultaneously and
only ones during one experimental step.
.SS <record>
.sp
The \fBrecord\fP tag defines the fetched data by its name. It has an attrbute
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fBname\fP which for the TANGO data source type a name of the tango class member
.UNINDENT
.UNINDENT
.UNINDENT
.SS DB datasource
.sp
The \fIDB\fP datasource allows to read data from accessible databases. It should contain <database />
and <query> tags. An example of usage:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<datasource type="DB">
  <database dbname="tango" dbtype="MYSQL" hostname="haso.desy.de"/>
  <query format="SPECTRUM">
    SELECT pid FROM device limit 10
  </query>
</datasource>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS <database>
.sp
The \fBdatabase\fP tag specifies parameters to connect to the required database. It acquires
the attirbutes
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
.INDENT 2.0
.TP
.B \fBdbtype\fP describing a type of the database, i.e.
.INDENT 7.0
.IP \(bu 2
\fIORACLE\fP an ORACLE database
.IP \(bu 2
\fIMYSQL\fP a MySQL database
.IP \(bu 2
\fIPGSQL\fP a PostgreSQL database
.UNINDENT
.UNINDENT
.IP \(bu 2
\fBdbname\fP denoting a name of the database (optional)
.IP \(bu 2
\fBhostname\fP being a name of the host with the database (optional)
.IP \(bu 2
\fBport\fP corresponding to a port number related to the database (optional)
.IP \(bu 2
\fBuser\fP denoting a user name (optional)
.IP \(bu 2
\fBpasswd\fP being a user password (optional)
.IP \(bu 2
\fBmycnf\fP defining a location of the my.cnf file with MySQL database access configuration (optional)
.IP \(bu 2
\fBnode\fP corresponding to a node parameter for the ORACLE database(optional)
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The \fBcontent\fP of the database tag defines Oracle DSN string (optional)
.SS <query>
.sp
The \fBquery\fP tag defines the database query which fetches the data. It has one attribute
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
.INDENT 2.0
.TP
.B \fBformat\fP which specifies a dimension of the fetch data, i.e.
.INDENT 7.0
.IP \(bu 2
\fISCALAR\fP corresponds to 0\-dimensional data, e.g. a separate numerical value or string
.IP \(bu 2
\fISPECTRUM\fP is related to 1\-dimensional data, e.g. a list of numerical values or strings
.IP \(bu 2
.INDENT 2.0
.TP
.B \fIIMAGE\fP describes 2\-dimensional data, i.e. a table of specific type values,
e.g. a table of strings
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The \fBcontent\fP of the query tags is the SQL query.
Another example of usage:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<datasource type="DB">
  <database dbname="mydb" dbtype="PGSQL"/>
  <query format="IMAGE">
    SELECT * FROM weather limit 3
  </query>
</datasource>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS PYEVAL datasource
.sp
The \fBPYEVAL\fP datasource allows to read data from other datasources and evaluate it
by user python script. An example of usage:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<datasource type="PYEVAL">
  <datasource type="TANGO" name="position">
    <device hostname="haso.desy.de" member="attribute" name="p09/motor/exp.01" port="10000"/>
    <record name="Position"/>
  </datasource>
  <datasource type="CLIENT" name="shift">
    <record name="exp_c01"/>
  </datasource>
  <result name="finalposition">
    ds.finalposition = ds.position + ds.shift
  </result>
</datasource>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS <datasource>
.sp
The \fBPYEVAL\fP datasource can contain other datasources. They have to have defined \fBname\fP attributes.
Those names with additional prefix \(aqds.\(aq correspond to input variable names from the python script,
i.e. ds.name.
.SS <result>
.sp
The \fBresult\fP contains python script which evaluates input data. It has the following attribute:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fBname\fP corresponding to a result name. It is related to python script variable by ds.name.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The default value \fBname\fP ="result". (optional)
.SH CLIENT CODE
.sp
In order to use Nexus Data Server one has to write a client code. Some simple client codes
are in the  nexdatas repository. In this section we add some
comments related to the client code.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# To use the Tango Server we must import the PyTango module and
# create DeviceProxy for the server.

import PyTango

device = "p09/tdw/r228"
dpx = PyTango.DeviceProxy(device)
dpx.set_timeout_millis(10000)

dpx.Init()

# Here device corresponds to a name of our Nexus Data Server.
# The Init() method resets the state of the server.

dpx.FileName = "test.h5"
dpx.OpenFile()

# We set the name of the output HDF5 file and open it.

# Now we are ready to pass the XML settings describing a structure of
# the output file as well as defining a way of data storing.
# Examples of the XMLSettings can be found in the XMLExamples directory.

xml = open("test.xml", \(aqr\(aq).read()
dpx.XMLSettings = xml

dpx.JSONRecord = \(aq{"data": {"parameterA":0.2},
                      "decoders":{"DESY2D":"desydecoders.desy2Ddec.desy2d"},
                      "datasources":{
                           "MCLIENT":"sources.DataSources.LocalClientSource"}
}\(aq

dpx.OpenEntry()

# We read our XML settings settings from a file and pass them to the server via
# the XMLSettings attribute. Then we open an entry group related to the XML
# configuration. Optionally, we can also set JSONRecord, i.e. an attribute
# which contains a global JSON string with data needed to store during opening
# the entry and also other stages of recording. If external decoder for
# DevEncoded data is need one can registred it passing its packages and
# class names in JSONRecord,
# e.g. "desy2d" class of "DESY2D" label in "desydecoders.desy2Ddec" package.
# Similarly making use of "datasources" records of the JSON string one can
# registred additional datasources. The OpenEntry method stores data defined
# in the XML string with strategy=INIT.
# The JSONRecord attribute can be changed during recording our data.

# After finalization of the configuration process we can start recording
# the main experiment data in a STEP mode.

dpx.Record(\(aq{"data": {"p09/counter/exp.01":0.1, "p09/counter/exp.02":1.1}}\(aq)

# Every time we call the Record method all nexus fields defined with
# strategy=STEP are extended by one record unit and the assigned to them data
# is stored. As the method argument we pass a local JSON string with the client
# data. To record the client data one can also use the global JSONRecord string.
# Contrary to the global JSON string the local one is only
# valid during one record step.

dpx.Record(\(aq{"data": {"emittance_x": 0.1},  "triggers":["trigger1", "trigger2"]  }\(aq)

# If you denote in your XML configuration string some fields by additional
# trigger attributes you may ask the server to store your data only in specific
# record steps. This can be helpful if you want to store your data in
# asynchronous mode. To this end you define in the local JSON string a list of
# triggers which are used in the current record step.

dpx.JSONRecord = \(aq{"data": {"parameterB":0.3}}\(aq
dpx.CloseEntry()

# After scanning experiment data in \(aqSTEP\(aq mode we close the entry.
# To this end we call the CloseEntry method which also stores data defined
# with strategy=FINAL. Since our HDF5 file can contains many entries we can again
# open the entry and repeat our record procedure. If we define more than one entry
# in one XML setting string the defined entries are recorded parallel
# with the same steps.

# Finally, we can close our output file by

dpx.CloseFile()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Additionally, one can use asynchronous versions of \fBOpenEntry\fP, \fBRecord\fP, \fBCloseEntry\fP, i.e.
\fBOpenEntryAsynch\fP, \fBRecordAsynch\fP, \fBCloseEntryAsynch\fP\&. In this case data is stored
in a background thread and during this writing Tango Data Server has a state \fIRUNNING\fP\&.
.sp
In order to build the XML configurations in the easy way the authors of the server provide
for this purpose a specialized GUI tool, Component Designer.
The attached to the server XML examples
was created by XMLFile class defined in XMLCreator/simpleXML.py.
.SH NXSWRITER PACKAGE
.SS Submodules
.SS nxswriter.ClientSource module
.sp
Definitions of CLIENT datasource
.INDENT 0.0
.TP
.B class nxswriter.ClientSource.ClientSource
Bases: \fBnxswriter.DataSources.DataSource\fP
.sp
Client data source
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It cleans all member variables
.UNINDENT
.INDENT 7.0
.TP
.B getData()
provides access to the data
.INDENT 7.0
.TP
.B Returns
dictionary with collected data
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B name = None
name of data
.UNINDENT
.INDENT 7.0
.TP
.B setJSON(globalJSON, localJSON=None)
sets JSON string
.INDENT 7.0
.TP
.B Brief
It sets the currently used  JSON string
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBglobalJSON\fP \-\- static JSON string
.IP \(bu 2
\fBlocalJSON\fP \-\- dynamic JSON string
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setup(xml)
sets the parrameters up from xml
.INDENT 7.0
.TP
.B Brief xml
datasource parameters
.UNINDENT
.UNINDENT
.UNINDENT
.SS nxswriter.DBaseSource module
.sp
Definitions of DB datasource
.INDENT 0.0
.TP
.B nxswriter.DBaseSource.DB_AVAILABLE = [\(aqMYSQL\(aq, \(aqPGSQL\(aq, \(aqORACLE\(aq]
list of available databases
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.DBaseSource.DBaseSource
Bases: \fBnxswriter.DataSources.DataSource\fP
.sp
DataBase data source
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It cleans all member variables
.UNINDENT
.INDENT 7.0
.TP
.B dbname = None
database name
.UNINDENT
.INDENT 7.0
.TP
.B dbtype = None
database type, i.e. MYSQL, PGSQL, ORACLE
.UNINDENT
.INDENT 7.0
.TP
.B dsn = None
DSN string
.UNINDENT
.INDENT 7.0
.TP
.B format = None
record format, i.e. SCALAR, SPECTRUM, IMAGE
.UNINDENT
.INDENT 7.0
.TP
.B getData()
provides access to the data
.INDENT 7.0
.TP
.B Returns
dictionary with collected data
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B hostname = None
name of the host with the data source
.UNINDENT
.INDENT 7.0
.TP
.B mode = None
oracle database mode
.UNINDENT
.INDENT 7.0
.TP
.B mycnf = None
mysql database configuration file
.UNINDENT
.INDENT 7.0
.TP
.B passwd = None
database password
.UNINDENT
.INDENT 7.0
.TP
.B port = None
port related to the host
.UNINDENT
.INDENT 7.0
.TP
.B query = None
database query
.UNINDENT
.INDENT 7.0
.TP
.B setup(xml)
sets the parrameters up from xml
.INDENT 7.0
.TP
.B Param
xml  datasource parameters
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B user = None
database user
.UNINDENT
.UNINDENT
.SS nxswriter.DataHolder module
.sp
definition of a data holder with casting methods
.INDENT 0.0
.TP
.B class nxswriter.DataHolder.DataHolder(rank, value, tangoDType, shape, encoding=None, decoders=None)
Bases: \fBobject\fP
.sp
Holder for passing data
.sp
constructor
:param rank: format of the data, i.e. SCALAR, SPECTRUM, IMAGE
:param value: value of the data. It may be also 1D and 2D array
:param tangoDType: type of the data
:param shape: shape of the data
:param encoding: encoding type of Tango DevEncoded varibles
:param decoders: poll with decoding classes
.INDENT 7.0
.TP
.B cast(dtype)
casts the data into given type
.INDENT 7.0
.TP
.B Parameters
\fBdtype\fP \-\- given type of data
.TP
.B Returns
numpy array of defined type or list
for strings or value for SCALAR
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B decoders = None
pool with decoding algorithm
.UNINDENT
.INDENT 7.0
.TP
.B encoding = None
encoding type of Tango DevEncoded varibles
.UNINDENT
.INDENT 7.0
.TP
.B format = None
data format
.UNINDENT
.INDENT 7.0
.TP
.B shape = None
data shape
.UNINDENT
.INDENT 7.0
.TP
.B tangoDType = None
data type
.UNINDENT
.INDENT 7.0
.TP
.B value = None
data value
.UNINDENT
.UNINDENT
.SS nxswriter.DataSourceFactory module
.sp
factory with datasources
.INDENT 0.0
.TP
.B class nxswriter.DataSourceFactory.DataSourceFactory(attrs, last)
Bases: \fBnxswriter.Element.Element\fP
.sp
Data source creator
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBattrs\fP \-\- dictionary with the tag attributes
.IP \(bu 2
\fBlast\fP \-\- the last element on the stack
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setDataSources(datasources)
sets the used datasources
.INDENT 7.0
.TP
.B Parameters
\fBdatasources\fP \-\- pool to be set
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setDecoders(decoders)
sets the used decoders
.INDENT 7.0
.TP
.B Parameters
\fBdecoders\fP \-\- pool to be set
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B store(xml=None, globalJSON=None)
sets the datasource form xml string
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBxml\fP \-\- input parameter
.IP \(bu 2
\fBglobalJSON\fP \-\- global JSON string
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS nxswriter.DataSourcePool module
.sp
pool with datasource evaluation classes
.INDENT 0.0
.TP
.B class nxswriter.DataSourcePool.DataSourcePool(configJSON=None)
Bases: \fBobject\fP
.sp
DataSource pool
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It creates know datasources
.TP
.B Parameters
\fBconfigJSON\fP \-\- string with datasources
.UNINDENT
.INDENT 7.0
.TP
.B append(datasource, name)
adds additional datasource
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP \-\- name of the adding datasource
.IP \(bu 2
\fBdatasource\fP \-\- instance of the adding datasource
.UNINDENT
.TP
.B Returns
name of datasource
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B appendUserDataSources(configJSON)
loads user datasources
.INDENT 7.0
.TP
.B Parameters
\fBconfigJSON\fP \-\- string with datasources
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B common = None
global variables for specific datasources
.UNINDENT
.INDENT 7.0
.TP
.B counter = None
step counter: INIT: \-1; STEP: 1,2,3...; FINAL: \-2;
.UNINDENT
.INDENT 7.0
.TP
.B get(datasource)
checks it the datasource is registered
.INDENT 7.0
.TP
.B Parameters
\fBdatasource\fP \-\- the given datasource name
.TP
.B Returns
datasource type if it the datasource
is registered
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B hasDataSource(datasource)
checks it the datasource is registered
.INDENT 7.0
.TP
.B Parameters
\fBdatasource\fP \-\- the given datasource
.TP
.B Returns
True if it the datasource is registered
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B lock = None
pool lock
.UNINDENT
.INDENT 7.0
.TP
.B pop(name)
adds additional datasource
.INDENT 7.0
.TP
.B Parameters
\fBname\fP \-\- name of the adding datasource
.UNINDENT
.UNINDENT
.UNINDENT
.SS nxswriter.DataSources module
.sp
Definitions of various datasources
.INDENT 0.0
.TP
.B class nxswriter.DataSources.DataSource
Bases: \fBobject\fP
.sp
Data source
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It cleans all member variables
.UNINDENT
.INDENT 7.0
.TP
.B getData()
access to data
.INDENT 7.0
.TP
.B Brief
It is an abstract method providing data
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B isValid()
checks if the data is valid
.INDENT 7.0
.TP
.B Returns
if the data is valid
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setup(xml)
sets the parrameters up from xml
.INDENT 7.0
.TP
.B Parameters
\fBxml\fP \-\- datasource parameters
.UNINDENT
.UNINDENT
.UNINDENT
.SS nxswriter.DecoderPool module
.sp
Provides a pool  with data decoders
.INDENT 0.0
.TP
.B class nxswriter.DecoderPool.DecoderPool(configJSON=None)
Bases: \fBobject\fP
.sp
Decoder pool
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It creates know decoders
.TP
.B Parameters
\fBconfigJSON\fP \-\- string with decoders
.UNINDENT
.INDENT 7.0
.TP
.B append(decoder, name)
adds additional decoder
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP \-\- name of the adding decoder
.IP \(bu 2
\fBdecoder\fP \-\- instance of the adding decoder
.UNINDENT
.TP
.B Returns
name of decoder
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B appendUserDecoders(configJSON)
loads user decoders
.INDENT 7.0
.TP
.B Parameters
\fBconfigJSON\fP \-\- string with decoders
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get(decoder)
checks it the decoder is registered
.INDENT 7.0
.TP
.B Parameters
\fBdecoder\fP \-\- the given decoder
.TP
.B Returns
True if it the decoder is registered
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B hasDecoder(decoder)
checks it the decoder is registered
.INDENT 7.0
.TP
.B Parameters
\fBdecoder\fP \-\- the given decoder
.TP
.B Returns
True if it the decoder is registered
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B pop(name)
adds additional decoder
.INDENT 7.0
.TP
.B Parameters
\fBname\fP \-\- name of the adding decoder
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.DecoderPool.UINT32decoder
Bases: \fBobject\fP
.sp
INT decoder
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It clears the local variables
.UNINDENT
.INDENT 7.0
.TP
.B decode()
provides the decoded data
.INDENT 7.0
.TP
.B Returns
the decoded data if data was loaded
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B dtype = None
data type
.UNINDENT
.INDENT 7.0
.TP
.B format = None
decoder format
.UNINDENT
.INDENT 7.0
.TP
.B load(data)
loads encoded data
.INDENT 7.0
.TP
.B Parameters
\fBdata\fP \-\- encoded data
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B name = None
decoder name
.UNINDENT
.INDENT 7.0
.TP
.B shape()
provides the data shape
.INDENT 7.0
.TP
.B Returns
the data shape if data was loaded
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.DecoderPool.UTF8decoder
Bases: \fBobject\fP
.sp
UTF8 decoder
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It clears the local variables
.UNINDENT
.INDENT 7.0
.TP
.B decode()
provides the decoded data
.INDENT 7.0
.TP
.B Returns
the decoded data if data was loaded
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B dtype = None
data type
.UNINDENT
.INDENT 7.0
.TP
.B format = None
decoder format
.UNINDENT
.INDENT 7.0
.TP
.B load(data)
loads encoded data
.INDENT 7.0
.TP
.B Parameters
\fBdata\fP \-\- encoded data
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B name = None
decoder name
.UNINDENT
.INDENT 7.0
.TP
.B shape()
provides the data shape
.INDENT 7.0
.TP
.B Returns
the data shape if data was loaded
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.DecoderPool.VDEOdecoder
Bases: \fBobject\fP
.sp
VIDEO IMAGE LIMA decoder
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It clears the local variables
.UNINDENT
.INDENT 7.0
.TP
.B decode()
provides the decoded data
.INDENT 7.0
.TP
.B Returns
the decoded data if data was loaded
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B dtype = None
data type
.UNINDENT
.INDENT 7.0
.TP
.B format = None
decoder format
.UNINDENT
.INDENT 7.0
.TP
.B load(data)
loads encoded data
.INDENT 7.0
.TP
.B Parameters
\fBdata\fP \-\- encoded data
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B name = None
decoder name
.UNINDENT
.INDENT 7.0
.TP
.B shape()
provides the data shape
.INDENT 7.0
.TP
.B Returns
the data shape if data was loaded
.UNINDENT
.UNINDENT
.UNINDENT
.SS nxswriter.EAttribute module
.sp
Definitions of attribute tag evaluation classes
.INDENT 0.0
.TP
.B class nxswriter.EAttribute.EAttribute(attrs, last)
Bases: \fBnxswriter.FElement.FElement\fP
.sp
attribute tag element
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBattrs\fP \-\- dictionary of the tag attributes
.IP \(bu 2
\fBlast\fP \-\- the last element from the stack
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B lengths = None
shape of the attribute
.UNINDENT
.INDENT 7.0
.TP
.B markFailed()
marks the field as failed
.INDENT 7.0
.TP
.B Brief
It marks the field as failed
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B name = None
attribute name
.UNINDENT
.INDENT 7.0
.TP
.B rank = None
rank of the attribute
.UNINDENT
.INDENT 7.0
.TP
.B run()
runner
.INDENT 7.0
.TP
.B Brief
During its thread run it fetches the data from the source
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B store(xml=None, globalJSON=None)
stores the tag content
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBxml\fP \-\- xml setting
.IP \(bu 2
\fBglobalJSON\fP \-\- global JSON string
.UNINDENT
.TP
.B Returns
(strategy,trigger)
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B strategy = None
strategy, i.e. INIT, STEP, FINAL
.UNINDENT
.INDENT 7.0
.TP
.B trigger = None
trigger for asynchronous writting
.UNINDENT
.UNINDENT
.SS nxswriter.EField module
.sp
Definitions of field tag evaluation classes
.INDENT 0.0
.TP
.B class nxswriter.EField.EField(attrs, last)
Bases: \fBnxswriter.FElement.FElementWithAttr\fP
.sp
field H5 tag element
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBattrs\fP \-\- dictionary of the tag attributes
.IP \(bu 2
\fBlast\fP \-\- the last element from the stack
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B compression = None
compression flag
.UNINDENT
.INDENT 7.0
.TP
.B grows = None
growing dimension
.UNINDENT
.INDENT 7.0
.TP
.B lengths = None
shape of the field
.UNINDENT
.INDENT 7.0
.TP
.B markFailed()
marks the field as failed
.INDENT 7.0
.TP
.B Brief
It marks the field as failed
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B postrun = None
label for postprocessing data
.UNINDENT
.INDENT 7.0
.TP
.B rank = None
rank of the field
.UNINDENT
.INDENT 7.0
.TP
.B rate = None
compression rate
.UNINDENT
.INDENT 7.0
.TP
.B run()
runner
.INDENT 7.0
.TP
.B Brief
During its thread run it fetches the data from the source
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B shuffle = None
compression shuffle
.UNINDENT
.INDENT 7.0
.TP
.B store(xml=None, globalJSON=None)
stores the tag content
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBxml\fP \-\- xml setting
.IP \(bu 2
\fBglobalJSON\fP \-\- global JSON string
.UNINDENT
.TP
.B Returns
(strategy, trigger)
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B strategy = None
strategy, i.e. INIT, STEP, FINAL, POSTRUN
.UNINDENT
.INDENT 7.0
.TP
.B trigger = None
trigger for asynchronous writing
.UNINDENT
.UNINDENT
.SS nxswriter.EGroup module
.sp
Definitions of group tag evaluation classes
.INDENT 0.0
.TP
.B class nxswriter.EGroup.EGroup(attrs, last)
Bases: \fBnxswriter.FElement.FElementWithAttr\fP
.sp
group H5 tag element
.sp
constructor
.sp
:param attrs dictionary of the tag attributes
:param last the last element from the stack
.INDENT 7.0
.TP
.B h5Object = None
stored H5 file object (defined in base class)
.UNINDENT
.INDENT 7.0
.TP
.B store(xml=None, globalJSON=None)
stores the tag content
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBxml\fP \-\- xml setting
.IP \(bu 2
\fBglobalJSON\fP \-\- global JSON string
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS nxswriter.ELink module
.sp
Definitions of link tag evaluation classes
.INDENT 0.0
.TP
.B class nxswriter.ELink.ELink(attrs, last)
Bases: \fBnxswriter.FElement.FElement\fP
.sp
link H5 tag element
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBattrs\fP \-\- dictionary of the tag attributes
.IP \(bu 2
\fBlast\fP \-\- the last element from the stack
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B createLink(groupTypes=None, target=None)
creates the link the H5 file
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBgroupTypes\fP \-\- dictionary with type:name group pairs
.IP \(bu 2
\fBtarget\fP \-\- NeXus target path
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B h5Object = None
stored H5 file object (defined in base class)
.UNINDENT
.INDENT 7.0
.TP
.B run()
runner
.INDENT 7.0
.TP
.B Brief
During its thread run it fetches the data from the source
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B store(xml=None, globalJSON=None)
stores the tag content
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBxml\fP \-\- xml setting
.IP \(bu 2
\fBglobalJSON\fP \-\- global JSON string
.UNINDENT
.TP
.B Returns
(strategy, trigger)
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B strategy = None
strategy, i.e. INIT, STEP, FINAL
.UNINDENT
.INDENT 7.0
.TP
.B trigger = None
trigger for asynchronous writting
.UNINDENT
.UNINDENT
.SS nxswriter.EStrategy module
.sp
Definitions of strategy evaluation classes
.INDENT 0.0
.TP
.B class nxswriter.EStrategy.EStrategy(attrs, last)
Bases: \fBnxswriter.Element.Element\fP
.sp
## strategy tag element
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBattrs\fP \-\- dictionary of the tag attributes
.IP \(bu 2
\fBlast\fP \-\- the last element from the stack
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B store(xml=None, globalJSON=None)
stores the tag content
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBxml\fP \-\- xml setting
.IP \(bu 2
\fBglobalJSON\fP \-\- global JSON string
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS nxswriter.Element module
.sp
Provides the base class Element for xml tags
.INDENT 0.0
.TP
.B class nxswriter.Element.Element(name, attrs, last=None)
Bases: \fBobject\fP
.sp
Tag element stored on our stack
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP \-\- tag name
.IP \(bu 2
\fBattrs\fP \-\- dictionary of the tag attributes
.IP \(bu 2
\fBlast\fP \-\- the last element from the stack
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B content = None
stored tag content
.UNINDENT
.INDENT 7.0
.TP
.B doc = None
doc string
.UNINDENT
.INDENT 7.0
.TP
.B last = None
the previous element
.UNINDENT
.INDENT 7.0
.TP
.B store(xml=None, globalJSON=None)
stores the tag
.INDENT 7.0
.TP
.B Brief
abstract method to store the tag element
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBxml\fP \-\- tuple of xml code
.IP \(bu 2
\fBglobalJSON\fP \-\- global JSON string
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B tagName = None
stored tag name
.UNINDENT
.UNINDENT
.SS nxswriter.ElementThread module
.sp
Implementation of element thread of tag evaluation
.INDENT 0.0
.TP
.B class nxswriter.ElementThread.ElementThread(index, queue)
Bases: \fBthreading.Thread\fP
.sp
single thread element
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It creates ElementThread from the runnable element
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBindex\fP \-\- the current thread index
.IP \(bu 2
\fBqueue\fP \-\- queue with tasks
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B index = None
thread index
.UNINDENT
.INDENT 7.0
.TP
.B run()
runner
.INDENT 7.0
.TP
.B Brief
It runs the defined thread
.UNINDENT
.UNINDENT
.UNINDENT
.SS nxswriter.Errors module
.sp
Tango Data Writer errors
.INDENT 0.0
.TP
.B exception nxswriter.Errors.CorruptedFieldArrayError
Bases: \fBexceptions.Exception\fP
.sp
exception for corrupted FieldArray
.UNINDENT
.INDENT 0.0
.TP
.B exception nxswriter.Errors.DataSourceError
Bases: \fBexceptions.Exception\fP
.sp
exception for fetching data from data source
.UNINDENT
.INDENT 0.0
.TP
.B exception nxswriter.Errors.DataSourceSetupError
Bases: \fBexceptions.Exception\fP
.sp
exception for setting data source
.UNINDENT
.INDENT 0.0
.TP
.B exception nxswriter.Errors.PackageError
Bases: \fBexceptions.Exception\fP
.sp
exception for fetching data from data source
.UNINDENT
.INDENT 0.0
.TP
.B exception nxswriter.Errors.ThreadError
Bases: \fBexceptions.Exception\fP
.sp
exception for problems in thread
.UNINDENT
.INDENT 0.0
.TP
.B exception nxswriter.Errors.UnsupportedTagError
Bases: \fBexceptions.Exception\fP
.sp
unsupported tag exception
.UNINDENT
.INDENT 0.0
.TP
.B exception nxswriter.Errors.XMLSettingSyntaxError
Bases: \fBexceptions.Exception\fP
.sp
exception for syntax in XML settings
.UNINDENT
.INDENT 0.0
.TP
.B exception nxswriter.Errors.XMLSyntaxError
Bases: \fBexceptions.Exception\fP
.sp
exception for syntax in XML settings
.UNINDENT
.SS nxswriter.FElement module
.sp
Definitions of file tag evaluation classes
.INDENT 0.0
.TP
.B class nxswriter.FElement.FElement(name, attrs, last, h5object=None)
Bases: \fBnxswriter.Element.Element\fP
.sp
NeXuS runnable tag element
tag element corresponding to one of H5 objects
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP \-\- tag name
.IP \(bu 2
\fBattrs\fP \-\- dictionary of the tag attributes
.IP \(bu 2
\fBlast\fP \-\- the last element from the stack
.IP \(bu 2
\fBh5object\fP \-\- H5 file object
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B canfail = None
.INDENT 7.0
.INDENT 3.5
flag for devices for which is allowed to failed
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B error = None
notification of error in the run method
.UNINDENT
.INDENT 7.0
.TP
.B h5Object = None
stored H5 file object
.UNINDENT
.INDENT 7.0
.TP
.B run()
runner
.INDENT 7.0
.TP
.B Brief
During its thread run it fetches the data from the source
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setMessage(exceptionMessage=None)
creates the error message
.INDENT 7.0
.TP
.B Parameters
\fBexceptionMessage\fP \-\- additional message of exception
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B source = None
data source
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.FElement.FElementWithAttr(name, attrs, last, h5object=None)
Bases: \fBnxswriter.FElement.FElement\fP
.sp
NeXuS runnable tag element with attributes
tag element corresponding to one of H5 objects with attributes
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP \-\- tag name
.IP \(bu 2
\fBattrs\fP \-\- dictionary of the tag attributes
.IP \(bu 2
\fBlast\fP \-\- the last element from the stack
.IP \(bu 2
\fBh5object\fP \-\- H5 file object
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B h5Attribute(name)
provides attribute h5 object
.INDENT 7.0
.TP
.B Parameters
\fBname\fP \-\- attribute name
.TP
.B Returns
instance of the attribute object if created
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B tagAttributes = None
dictionary with attribures from sepatare attribute tags
.UNINDENT
.UNINDENT
.SS nxswriter.FetchNameHandler module
.sp
SAX parser for fetching name attributes of tags
.INDENT 0.0
.TP
.B class nxswriter.FetchNameHandler.FetchNameHandler
Bases: \fBxml.sax.handler.ContentHandler\fP
.sp
SAX2 parser
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It constructs parser handler for fetching group names
.UNINDENT
.INDENT 7.0
.TP
.B characters(content)
adds the tag content
.INDENT 7.0
.TP
.B Parameters
\fBcontent\fP \-\- partial content of the tag
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B endElement(name)
parses an closing tag
.INDENT 7.0
.TP
.B Parameters
\fBname\fP \-\- tag name
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B groupTypes = None
tree of TNObjects with names and types
.UNINDENT
.INDENT 7.0
.TP
.B startElement(name, attrs)
parses the opening tag
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP \-\- tag name
.IP \(bu 2
\fBattrs\fP \-\- attribute dictionary
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.FetchNameHandler.TNObject(name=\(aqroot\(aq, nxtype=None, parent=None)
Bases: \fBobject\fP
.sp
Type Name object
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It sets default values of TNObject
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP \-\- name of the object
.IP \(bu 2
\fBnxtype\fP \-\- Nexus type of the object
.IP \(bu 2
\fBparent\fP \-\- object parent
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B child(name=\(aq\(aq, nxtype=\(aq\(aq)
get child by name or nxtype
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP \-\- group name
.IP \(bu 2
\fBnxtype\fP \-\- nexus group type
.UNINDENT
.TP
.B Returns
child instance
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B children = None
object children
.UNINDENT
.INDENT 7.0
.TP
.B name = None
object name
.UNINDENT
.INDENT 7.0
.TP
.B nxtype = None
object Nexus type
.UNINDENT
.INDENT 7.0
.TP
.B parent = None
object parent
.UNINDENT
.UNINDENT
.SS nxswriter.H5Elements module
.sp
Definitions of tag evaluation classes
.INDENT 0.0
.TP
.B class nxswriter.H5Elements.EDim(attrs, last)
Bases: \fBnxswriter.Element.Element\fP
.sp
dim tag element
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBattrs\fP \-\- dictionary of the tag attributes
.IP \(bu 2
\fBlast\fP \-\- the last element from the stack
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B content = None
tag content
.UNINDENT
.INDENT 7.0
.TP
.B source = None
datasource
.UNINDENT
.INDENT 7.0
.TP
.B store(xml=None, globalJSON=None)
stores the tag content
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBxml\fP \-\- xml setting
.IP \(bu 2
\fBglobalJSON\fP \-\- global JSON string
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.H5Elements.EDimensions(attrs, last)
Bases: \fBnxswriter.Element.Element\fP
.sp
dimensions tag element
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBattrs\fP \-\- dictionary of the tag attributes
.IP \(bu 2
\fBlast\fP \-\- the last element from the stack
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.H5Elements.EDoc(attrs, last)
Bases: \fBnxswriter.Element.Element\fP
.sp
doc tag element
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBattrs\fP \-\- dictionary of the tag attributes
.IP \(bu 2
\fBlast\fP \-\- the last element from the stack
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B store(xml=None, globalJSON=None)
stores the tag content
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBxml\fP \-\- xml setting
.IP \(bu 2
\fBglobalJSON\fP \-\- global JSON string
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.H5Elements.EFile(attrs, last, h5fileObject)
Bases: \fBnxswriter.FElement.FElement\fP
.sp
file H5 element
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBattrs\fP \-\- dictionary of the tag attributes
.IP \(bu 2
\fBlast\fP \-\- the last element from the stack
.IP \(bu 2
\fBh5fileObject\fP \-\- H5 file object
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.H5Elements.ESymbol(attrs, last)
Bases: \fBnxswriter.Element.Element\fP
.sp
symbol tag element
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBattrs\fP \-\- dictionary of the tag attributes
.IP \(bu 2
\fBlast\fP \-\- the last element from the stack
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B store(xml=None, globalJSON=None)
stores the tag content
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBxml\fP \-\- xml setting2
.IP \(bu 2
\fBglobalJSON\fP \-\- global JSON string
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B symbols = None
dictionary with symbols
.UNINDENT
.UNINDENT
.SS nxswriter.InnerXMLParser module
.sp
SAX parser for taking XML string inside specified tag
.INDENT 0.0
.TP
.B class nxswriter.InnerXMLParser.InnerXMLHandler(xmlReader, contentHandler, name, attrs)
Bases: \fBxml.sax.handler.ContentHandler\fP
.sp
Inner SAX2 parser
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It constructs parser handler for taking xml od datasources
.UNINDENT
.INDENT 7.0
.TP
.B characters(content)
adds the tag content
.INDENT 7.0
.TP
.B Parameters
\fBcontent\fP \-\- partial content of the tag
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B endElement(name)
parses an closing tag
.INDENT 7.0
.TP
.B Parameters
\fBname\fP \-\- tag name
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B startElement(name, attrs)
parses the opening tag
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP \-\- tag name
.IP \(bu 2
\fBattrs\fP \-\- attribute dictionary
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B xml = None
xml string
.UNINDENT
.UNINDENT
.SS nxswriter.NXSWriter module
.sp
Nexus Data Writer \- Tango Server
.INDENT 0.0
.TP
.B class nxswriter.NXSWriter.CommandThread(server, command, finalState, args=None)
Bases: \fBthreading.Thread\fP
.sp
thread with server command
.sp
constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBserver\fP \-\- Device_4Impl    Tango server implementation
.IP \(bu 2
\fBcommand\fP \-\- __callable__    Thread command
.IP \(bu 2
\fBfinalState\fP \-\- DevState        Final State Code
.IP \(bu 2
\fBargs\fP \-\- list            List of command arguments
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B args = None
command arguments
.UNINDENT
.INDENT 7.0
.TP
.B command = None
command
.UNINDENT
.INDENT 7.0
.TP
.B estate = None
error state
.UNINDENT
.INDENT 7.0
.TP
.B fstate = None
final state
.UNINDENT
.INDENT 7.0
.TP
.B run()
runs the given command on the server and changes the state on exit
.UNINDENT
.INDENT 7.0
.TP
.B server = None
tango server
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.NXSWriter.NXSDataWriter(cl, name)
Bases: \fBPyTango._PyTango.Device_4Impl\fP
.sp
Tango Server to store data in H5 files
.INDENT 7.0
.TP
.B Brief
Device States Description:
DevState.ON :       NeXuS Data Server is switch on
DevState.OFF :      NeXuS Data Writer is switch off
DevState.EXTRACT :  H5 file is open
DevState.OPEN :     XML configuration is initialzed
DevState.RUNNING :  NeXus Data Server is writing
DevState.FAULT :    Error state
.UNINDENT
.sp
Device constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcl\fP \-\- class name
.IP \(bu 2
\fBname\fP \-\- device name
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B CloseEntry()
CloseEntry command
.INDENT 7.0
.TP
.B Brief
Closing the entry
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B CloseEntryAsynch()
CloseEntryAsynch command
.INDENT 7.0
.TP
.B Brief
Closing the entry is asynchronous mode
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B CloseFile()
CloseFile command
.INDENT 7.0
.TP
.B Brief
Close the H5 file
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B OpenEntry()
OpenEntry command
.INDENT 7.0
.TP
.B Brief
Creating the new entry
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B OpenEntryAsynch()
OpenEntryAsynch command
.INDENT 7.0
.TP
.B Brief
Creating the new entry in asynchronous mode
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B OpenFile()
OpenFile command
.INDENT 7.0
.TP
.B Brief
Open the H5 file
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Record(argin)
Record command
.INDENT 7.0
.TP
.B Brief
Record setting for one step
.TP
.B Parameters
\fBargin\fP \-\- DevString    JSON string with data
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B RecordAsynch(argin)
RecordAsynch command
.INDENT 7.0
.TP
.B Brief
Record setting for one step in asynchronous mode
.TP
.B Parameters
\fBargin\fP \-\- DevString    JSON string with data
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B always_executed_hook()
Always excuted hook method
.UNINDENT
.INDENT 7.0
.TP
.B cthread = None
closentry thread
.UNINDENT
.INDENT 7.0
.TP
.B delete_device()
Device destructor
.UNINDENT
.INDENT 7.0
.TP
.B dev_state()
State command
.INDENT 7.0
.TP
.B Brief
This command gets the device state
(stored in its <i>device_state</i> data member)
and returns it to the caller.
.TP
.B Returns
DevState    State Code
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B dev_status()
Status command
.INDENT 7.0
.TP
.B Brief
This command gets the device status
(stored in its <i>device_status</i> data member)
and returns it to the caller.
.TP
.B Returns
ConstDevString    Status description
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B errors = None
list with errors
.UNINDENT
.INDENT 7.0
.TP
.B get_state()
get_state method
.INDENT 7.0
.TP
.B Returns
DevState    State Code
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B init_device()
Device initialization
.UNINDENT
.INDENT 7.0
.TP
.B is_CloseEntryAsynch_allowed()
CloseEntryAsynch command State Machine
.UNINDENT
.INDENT 7.0
.TP
.B is_CloseEntry_allowed()
CloseEntry command State Machine
.UNINDENT
.INDENT 7.0
.TP
.B is_CloseFile_allowed()
CloseFile command State Machine
.UNINDENT
.INDENT 7.0
.TP
.B is_FileName_allowed(_)
FileName attribute State Machine
.UNINDENT
.INDENT 7.0
.TP
.B is_FileName_write_allowed()
FileName attribute Write State Machine
.UNINDENT
.INDENT 7.0
.TP
.B is_JSONRecord_allowed(_)
JSONRecord attribute State Machine
.UNINDENT
.INDENT 7.0
.TP
.B is_OpenEntryAsynch_allowed()
OpenEntryAsynch command State Machine
.UNINDENT
.INDENT 7.0
.TP
.B is_OpenEntry_allowed()
OpenEntry command State Machine
.UNINDENT
.INDENT 7.0
.TP
.B is_OpenFile_allowed()
OpenFile command State Machine
.UNINDENT
.INDENT 7.0
.TP
.B is_RecordAsynch_allowed()
RecordAsynch command State Machine
.UNINDENT
.INDENT 7.0
.TP
.B is_Record_allowed()
Record command State Machine
.UNINDENT
.INDENT 7.0
.TP
.B is_XMLSettings_allowed(_)
XMLSettings attribute State Machine
.UNINDENT
.INDENT 7.0
.TP
.B othread = None
openentry thread
.UNINDENT
.INDENT 7.0
.TP
.B read_Errors(attr)
Read Errors attribute
.UNINDENT
.INDENT 7.0
.TP
.B read_FileName(attr)
Read FileName attribute
.UNINDENT
.INDENT 7.0
.TP
.B read_JSONRecord(attr)
Read JSONRecord attribute
.UNINDENT
.INDENT 7.0
.TP
.B read_XMLSettings(attr)
Read XMLSettings attribute
.UNINDENT
.INDENT 7.0
.TP
.B read_attr_hardware(_)
Read Attribute Hardware
.UNINDENT
.INDENT 7.0
.TP
.B rthread = None
record thread
.UNINDENT
.INDENT 7.0
.TP
.B set_state(state)
set_state method
.INDENT 7.0
.TP
.B Parameters
\fBstate\fP \-\- DevState    State Code
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B state_flag = None
state flag
.UNINDENT
.INDENT 7.0
.TP
.B tdw = None
Tango Data Writer
.UNINDENT
.INDENT 7.0
.TP
.B write_FileName(attr)
Write FileName attribute
.UNINDENT
.INDENT 7.0
.TP
.B write_JSONRecord(attr)
Write JSONRecord attribute
.UNINDENT
.INDENT 7.0
.TP
.B write_XMLSettings(attr)
Write XMLSettings attribute
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.NXSWriter.NXSDataWriterClass(name)
Bases: \fBPyTango._PyTango.DeviceClass\fP
.sp
NXSDataWriterClass class definition
.sp
NXSDataWriterClass Constructor
.INDENT 7.0
.TP
.B attr_list = {\(aqErrors\(aq: [[PyTango._PyTango.CmdArgType.DevString, PyTango._PyTango.AttrDataFormat.SPECTRUM, PyTango._PyTango.AttrWriteType.READ, 1000], {\(aqdescription\(aq: \(aqlist of errors\(aq, \(aqlabel\(aq: \(aqlist of errors\(aq}], \(aqJSONRecord\(aq: [[PyTango._PyTango.CmdArgType.DevString, PyTango._PyTango.AttrDataFormat.SCALAR, PyTango._PyTango.AttrWriteType.READ_WRITE], {\(aqdescription\(aq: \(aqA JSON string with global client data.\(aq, \(aqDisplay level\(aq: PyTango._PyTango.DispLevel.EXPERT, \(aqlabel\(aq: \(aqJSON string with client data\(aq}], \(aqFileName\(aq: [[PyTango._PyTango.CmdArgType.DevString, PyTango._PyTango.AttrDataFormat.SCALAR, PyTango._PyTango.AttrWriteType.READ_WRITE], {\(aqdescription\(aq: \(aqA name of H5 output file with its full path\(aq, \(aqlabel\(aq: \(aqOutput file with its path\(aq}], \(aqXMLSettings\(aq: [[PyTango._PyTango.CmdArgType.DevString, PyTango._PyTango.AttrDataFormat.SCALAR, PyTango._PyTango.AttrWriteType.READ_WRITE], {\(aqdescription\(aq: \(aqAn XML string with Nexus configuration.\(aq, \(aqDisplay level\(aq: PyTango._PyTango.DispLevel.EXPERT, \(aqlabel\(aq: \(aqXML Configuration\(aq}]}
Attribute definitions
.UNINDENT
.INDENT 7.0
.TP
.B class_property_list = {}
Class Properties
.UNINDENT
.INDENT 7.0
.TP
.B cmd_list = {\(aqRecord\(aq: [[PyTango._PyTango.CmdArgType.DevString, \(aqJSON string with data\(aq], [PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq]], \(aqOpenFile\(aq: [[PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq], [PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq]], \(aqCloseEntryAsynch\(aq: [[PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq], [PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq]], \(aqCloseEntry\(aq: [[PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq], [PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq]], \(aqOpenEntryAsynch\(aq: [[PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq], [PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq]], \(aqRecordAsynch\(aq: [[PyTango._PyTango.CmdArgType.DevString, \(aqJSON string with data\(aq], [PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq]], \(aqOpenEntry\(aq: [[PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq], [PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq]], \(aqCloseFile\(aq: [[PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq], [PyTango._PyTango.CmdArgType.DevVoid, \(aq\(aq]]}
Command definitions
.UNINDENT
.INDENT 7.0
.TP
.B device_property_list = {\(aqNumberOfThreads\(aq: [PyTango._PyTango.CmdArgType.DevLong, \(aqmaximal number of threads\(aq, [100]]}
Device Properties
.UNINDENT
.UNINDENT
.SS nxswriter.NexusXMLHandler module
.sp
SAX parser for interpreting content of  XML configuration string
.INDENT 0.0
.TP
.B class nxswriter.NexusXMLHandler.NexusXMLHandler(fileElement, datasources=None, decoders=None, groupTypes=None, parser=None, globalJSON=None)
Bases: \fBxml.sax.handler.ContentHandler\fP
.sp
SAX2 parser
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It constructs parser and defines the H5 output file
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfileElement\fP \-\- file element
.IP \(bu 2
\fBdecoders\fP \-\- decoder pool
.IP \(bu 2
\fBdatasources\fP \-\- datasource pool
.IP \(bu 2
\fBgroupTypes\fP \-\- map of NXclass : name
.IP \(bu 2
\fBparser\fP \-\- instance of sax.xmlreader
.IP \(bu 2
\fBglobalJSON\fP \-\- global json string
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B characters(content)
adds the tag content
.INDENT 7.0
.TP
.B Parameters
\fBcontent\fP \-\- partial content of the tag
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B close()
closes the elements
.INDENT 7.0
.TP
.B Brief
It goes through all stack elements closing them
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B elementClass = None
map of tag names to related classes
.UNINDENT
.INDENT 7.0
.TP
.B endElement(name)
parses the closing tag
.INDENT 7.0
.TP
.B Parameters
\fBname\fP \-\- tag name
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B finalPool = None
thread pool with FINAL elements
.UNINDENT
.INDENT 7.0
.TP
.B initPool = None
thread pool with INIT elements
.UNINDENT
.INDENT 7.0
.TP
.B raiseUnsupportedTag = None
True if raise exception on unsupported tag
.UNINDENT
.INDENT 7.0
.TP
.B startElement(name, attrs)
parses the opening tag
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP \-\- tag name
.IP \(bu 2
\fBattrs\fP \-\- attribute dictionary
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B stepPool = None
thread pool with STEP elements
.UNINDENT
.INDENT 7.0
.TP
.B transparentTags = None
transparent tags
.UNINDENT
.INDENT 7.0
.TP
.B triggerPools = None
collection of thread pool with triggered STEP elements
.UNINDENT
.INDENT 7.0
.TP
.B withXMLinput = None
tags with innerxml as its input
.UNINDENT
.UNINDENT
.SS nxswriter.PyEvalSource module
.sp
Definitions of PYEVAL datasource
.INDENT 0.0
.TP
.B class nxswriter.PyEvalSource.PyEvalSource
Bases: \fBnxswriter.DataSources.DataSource\fP
.sp
Python Eval data source
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It cleans all member variables
.UNINDENT
.INDENT 7.0
.TP
.B getData()
provides access to the data
.INDENT 7.0
.TP
.B Returns
dictionary with collected data
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setDataSources(pool)
sets the datasources
.INDENT 7.0
.TP
.B Parameters
\fBpool\fP \-\- datasource pool
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setDecoders(decoders)
sets the used decoders
.INDENT 7.0
.TP
.B Parameters
\fBdecoders\fP \-\- pool to be set
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setJSON(globalJSON, localJSON=None)
sets JSON string
.INDENT 7.0
.TP
.B Brief
It sets the currently used  JSON string
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBglobalJSON\fP \-\- static JSON string
.IP \(bu 2
\fBlocalJSON\fP \-\- dynamic JSON string
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setup(xml)
sets the parrameters up from xml
.INDENT 7.0
.TP
.B Parameters
\fBxml\fP \-\- datasource parameters
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.PyEvalSource.Variables
Bases: \fBobject\fP
.sp
Variables for PyEval datasource
.UNINDENT
.SS nxswriter.Streams module
.sp
labels to Tango Streams
.INDENT 0.0
.TP
.B nxswriter.Streams.debug(message, std=True)
writes debug message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBmessage\fP \-\- debug message
.IP \(bu 2
\fBstd\fP \-\- it writes to sys stream
when log stream does not exist
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B nxswriter.Streams.error(message, std=True)
writes error message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBmessage\fP \-\- error message
.IP \(bu 2
\fBstd\fP \-\- it writes to sys stream
when log stream does not exist
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B nxswriter.Streams.fatal(message, std=True)
writes fatal error message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBmessage\fP \-\- error message
.IP \(bu 2
\fBstd\fP \-\- it writes to sys stream
when log stream does not exist
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B nxswriter.Streams.info(message, std=True)
writes info message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBmessage\fP \-\- info message
.IP \(bu 2
\fBstd\fP \-\- it writes to sys stream
when log stream does not exist
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B nxswriter.Streams.log_debug = None
Tango debug log stream
.UNINDENT
.INDENT 0.0
.TP
.B nxswriter.Streams.log_error = None
Tango error log stream
.UNINDENT
.INDENT 0.0
.TP
.B nxswriter.Streams.log_fatal = None
Tango fatal log stream
.UNINDENT
.INDENT 0.0
.TP
.B nxswriter.Streams.log_info = None
Tango info log stream
.UNINDENT
.INDENT 0.0
.TP
.B nxswriter.Streams.log_warn = None
Tango warn log stream
.UNINDENT
.INDENT 0.0
.TP
.B nxswriter.Streams.warn(message, std=True)
writes warning message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBmessage\fP \-\- warning message
.IP \(bu 2
\fBstd\fP \-\- it writes to sys stream
when log stream does not exist
.UNINDENT
.UNINDENT
.UNINDENT
.SS nxswriter.TangoDataWriter module
.sp
Tango Data Writer implementation
.INDENT 0.0
.TP
.B class nxswriter.TangoDataWriter.TangoDataWriter(server=None)
Bases: \fBobject\fP
.sp
NeXuS data writer
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It initialize the data writer for the H5 output file
.TP
.B Parameters
\fBserver\fP \-\- Tango server
.UNINDENT
.INDENT 7.0
.TP
.B addingLogs = None
adding logs
.UNINDENT
.INDENT 7.0
.TP
.B closeEntry()
closes the data entry
.INDENT 7.0
.TP
.B Brief
It runs threads from the FINAL pool and
removes the thread pools
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B closeFile()
the H5 file closing
.INDENT 7.0
.TP
.B Brief
It closes the H5 file
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B fileName = None
output file name
.UNINDENT
.INDENT 7.0
.TP
.B getFile()
the H5 file handle
.INDENT 7.0
.TP
.B Returns
the H5 file handle
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B jsonrecord
the json data string
.UNINDENT
.INDENT 7.0
.TP
.B numberOfThreads = None
maximal number of threads
.UNINDENT
.INDENT 7.0
.TP
.B openEntry()
opens the data entry corresponding to a new XML settings
.INDENT 7.0
.TP
.B Brief
It parse the XML settings, creates thread pools
and runs the INIT pool.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B openFile()
the H5 file opening
.INDENT 7.0
.TP
.B Brief
It opens the H5 file
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B record(jsonstring=None)
runs threads form the STEP pool
.INDENT 7.0
.TP
.B Brief
It runs threads from the STEP pool
.TP
.B Parameters
\fBjsonstring\fP \-\- local JSON string with data records
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B xmlsettings
the xmlsettings
.UNINDENT
.UNINDENT
.SS nxswriter.TangoSource module
.sp
Definitions of TANGO datasource
.INDENT 0.0
.TP
.B nxswriter.TangoSource.PYTANGO_AVAILABLE = True
global variable if PyTango module installed
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.TangoSource.ProxyTools
Bases: \fBobject\fP
.sp
tools for proxy
.INDENT 7.0
.TP
.B classmethod isProxyValid(proxy)
checks if proxy is valid
.INDENT 7.0
.TP
.B Parameters
\fBproxy\fP \-\- PyTango proxy
.TP
.B Returns
True if proxy is valid else false
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod proxySetup(device)
sets the Tango proxy up
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcls\fP \-\- ProxyTools class
.IP \(bu 2
\fBdevice\fP \-\- tango device
.UNINDENT
.TP
.B Returns
proxy if proxy is set up
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.TangoSource.TangoSource
Bases: \fBnxswriter.DataSources.DataSource\fP
.sp
Tango data source
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It cleans all member variables
.UNINDENT
.INDENT 7.0
.TP
.B client = None
client datasource for mixed CLIENT/TANGO mode
.UNINDENT
.INDENT 7.0
.TP
.B device = None
full device name
.UNINDENT
.INDENT 7.0
.TP
.B getData()
data provider
.INDENT 7.0
.TP
.B Returns
dictionary with collected data
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B group = None
datasource tango group
.UNINDENT
.INDENT 7.0
.TP
.B member = None
Tango device member
.UNINDENT
.INDENT 7.0
.TP
.B setDataSources(pool)
sets the datasources
.INDENT 7.0
.TP
.B Parameters
\fBpool\fP \-\- datasource pool
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setDecoders(decoders)
sets the used decoders
.INDENT 7.0
.TP
.B Parameters
\fBdecoders\fP \-\- pool to be set
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setJSON(globalJSON, localJSON=None)
sets JSON string
.INDENT 7.0
.TP
.B Brief
It sets the currently used  JSON string
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBglobalJSON\fP \-\- static JSON string
.IP \(bu 2
\fBlocalJSON\fP \-\- dynamic JSON string
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setup(xml)
sets the parrameters up from xml
.INDENT 7.0
.TP
.B Parameters
\fBxml\fP \-\- datasource parameters
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.TangoSource.TgDevice(device, proxy=None)
Bases: \fBobject\fP
.sp
tango device
.sp
default constructor
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdevice\fP \-\- tango device name
.IP \(bu 2
\fBproxy\fP \-\- device proxy
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B attributes = None
device attribute names
.UNINDENT
.INDENT 7.0
.TP
.B commands = None
device command names
.UNINDENT
.INDENT 7.0
.TP
.B device = None
tango device name
.UNINDENT
.INDENT 7.0
.TP
.B members = None
dictionary with tango members
.UNINDENT
.INDENT 7.0
.TP
.B properties = None
device property names
.UNINDENT
.INDENT 7.0
.TP
.B proxy = None
device proxy
.UNINDENT
.INDENT 7.0
.TP
.B setMember(member)
provides tango device member
.INDENT 7.0
.TP
.B Parameters
\fBmember\fP \-\- tango  device member
.TP
.B Returns
TgMember instance of tango device member
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.TangoSource.TgGroup(counter=0)
Bases: \fBobject\fP
.sp
Group of tango devices
.sp
default constructor
.INDENT 7.0
.TP
.B Parameters
\fBcounter\fP \-\- counts of steps
.UNINDENT
.INDENT 7.0
.TP
.B counter = None
counter of steps
.UNINDENT
.INDENT 7.0
.TP
.B devices = None
TANGO devices
.UNINDENT
.INDENT 7.0
.TP
.B getData(counter, proxy=None, member=None)
reads data from device proxy
:param counter: counts of scan steps
:param proxy: device proxy
:param member: required member
.UNINDENT
.INDENT 7.0
.TP
.B getDevice(device)
provides tango device
.INDENT 7.0
.TP
.B Parameters
\fBdevice\fP \-\- tango device name
.TP
.B Returns
TgDevice instance of tango device
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B lock = None
threading lock
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.TangoSource.TgMember(name, memberType=\(aqattribute\(aq, encoding=None)
Bases: \fBobject\fP
.sp
tango device member
.sp
default constructor
:param name: name of data record
:param memberType: member type of the data
:param encoding: encoding type of Tango DevEncoded variables
.INDENT 7.0
.TP
.B encoding = None
encoding type of Tango DevEncoded variables
.UNINDENT
.INDENT 7.0
.TP
.B getData(proxy)
reads data from device proxy
.INDENT 7.0
.TP
.B Parameters
\fBproxy\fP \-\- device proxy
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B getValue(decoders=None)
provides value of tango member
.INDENT 7.0
.TP
.B Parameters
\fBdecoders\fP \-\- decoder pool
.TP
.B Returns
dictionary with {"rank":, "value":, "tangoDType":,
"shape":, "encoding":, "decoders":}
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B isDataSet()
checks if data is set
.INDENT 7.0
.TP
.B Returns
True if data is set
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B memberType = None
member type of the data, i.e. attribute, property,...
.UNINDENT
.INDENT 7.0
.TP
.B name = None
name of data record
.UNINDENT
.INDENT 7.0
.TP
.B reset()
cleans output value
.UNINDENT
.INDENT 7.0
.TP
.B setData(data, cmd=None)
sets tango data
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdata\fP \-\- output tango data
.IP \(bu 2
\fBcmd\fP \-\- input command data
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS nxswriter.ThreadPool module
.sp
Provides a pool with element threads
.INDENT 0.0
.TP
.B class nxswriter.ThreadPool.ThreadPool(numberOfThreads=None)
Bases: \fBobject\fP
.sp
Pool with threads
.sp
constructor
.INDENT 7.0
.TP
.B Brief
It cleans the member variables
.TP
.B Parameters
\fBnumerOfThreads\fP \-\- number of threads
.UNINDENT
.INDENT 7.0
.TP
.B append(elem)
appends the thread element
:param elem: the thread element
.UNINDENT
.INDENT 7.0
.TP
.B checkErrors()
checks errors from threads
.UNINDENT
.INDENT 7.0
.TP
.B close()
closer
.INDENT 7.0
.TP
.B Brief
It close the threads from the pool
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B join(timeout=None)
waits for all thread from the pool
:param timeout: the maximal waiting time
.UNINDENT
.INDENT 7.0
.TP
.B numberOfThreads = None
maximal number of threads
.UNINDENT
.INDENT 7.0
.TP
.B run()
thread runner
.INDENT 7.0
.TP
.B Brief
It runs the threads from the pool
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B runAndWait()
runner with waiting
.INDENT 7.0
.TP
.B Brief
It runs and waits the threads from the pool
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B setJSON(globalJSON, localJSON=None)
sets the JSON string to threads
:param globalJSON: the static JSON string
:param localJSON: the dynamic JSON string
:returns: self object
.UNINDENT
.UNINDENT
.SS nxswriter.Types module
.sp
Types converters
.INDENT 0.0
.TP
.B class nxswriter.Types.Converters
Bases: \fBobject\fP
.sp
set of converters
.INDENT 7.0
.TP
.B classmethod toBool(value)
converts to bool
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcls\fP \-\- class instance
.IP \(bu 2
\fBvalue\fP \-\- variable to convert
.UNINDENT
.TP
.B Returns
result in bool type
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class nxswriter.Types.NTP
Bases: \fBobject\fP
.sp
type converter
.INDENT 7.0
.TP
.B aTn = {\(aqignoreExtraAttributes\(aq: \(aqNX_BOOLEAN\(aq, \(aqprimary\(aq: \(aqNX_INT32\(aq, \(aqfile_time\(aq: \(aqNX_DATE_TIME\(aq, \(aqoffset\(aq: \(aqNX_INT\(aq, \(aqfile_update_time\(aq: \(aqNX_DATE_TIME\(aq, \(aqignoreExtraFields\(aq: \(aqNX_BOOLEAN\(aq, \(aqaxis\(aq: \(aqNX_INT\(aq, \(aqignoreExtraGroups\(aq: \(aqNX_BOOLEAN\(aq, \(aqsignal\(aq: \(aqNX_INT\(aq, \(aqstride\(aq: \(aqNX_INT\(aq, \(aqrestricts\(aq: \(aqNX_INT\(aq, \(aqmaxOccus\(aq: \(aqNX_INT\(aq, \(aqminOccus\(aq: \(aqNX_INT\(aq}
map of tag attribute types
.UNINDENT
.INDENT 7.0
.TP
.B aTnv = {\(aqvector\(aq: \(aqNX_FLOAT\(aq}
map of vector tag attribute types
.UNINDENT
.INDENT 7.0
.TP
.B arrayRank(array)
array rank
.INDENT 7.0
.TP
.B Brief
It calculates the rank of the array
.TP
.B Parameters
\fBarray\fP \-\- given array
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B arrayRankRShape(array)
array rank, inverse shape and type
.INDENT 7.0
.TP
.B Brief
It calculates the rank, inverse shape and type of
the first element of the list array
.TP
.B Parameters
\fBarray\fP \-\- given array
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B arrayRankShape(array)
array rank, shape and type
.INDENT 7.0
.TP
.B Brief
It calculates the rank, shape and type of
the first element of the list array
.TP
.B Parameters
\fBarray\fP \-\- given array
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B convert = {\(aqfloat16\(aq: <type \(aqfloat\(aq>, \(aqint32\(aq: <type \(aqint\(aq>, \(aqint16\(aq: <type \(aqint\(aq>, \(aqstring\(aq: <type \(aqstr\(aq>, \(aqfloat64\(aq: <type \(aqfloat\(aq>, \(aqint\(aq: <type \(aqint\(aq>, \(aqfloat\(aq: <type \(aqfloat\(aq>, \(aquint8\(aq: <type \(aqint\(aq>, \(aquint32\(aq: <type \(aqlong\(aq>, \(aquint64\(aq: <type \(aqlong\(aq>, \(aquint16\(aq: <type \(aqint\(aq>, \(aqint64\(aq: <type \(aqlong\(aq>, \(aquint\(aq: <type \(aqint\(aq>, \(aqbool\(aq: <bound method type.toBool of <class \(aqnxswriter.Types.Converters\(aq>>, \(aqint8\(aq: <type \(aqint\(aq>, \(aqfloat32\(aq: <type \(aqfloat\(aq>}
map of type : converting function
.UNINDENT
.INDENT 7.0
.TP
.B createArray(value, fun=None)
.INDENT 7.0
.TP
.B creates python array from the given array with applied
the given function to it elements
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBvalue\fP \-\- given array
.IP \(bu 2
\fBfun\fP \-\- applied function
.UNINDENT
.TP
.B Returns
created array
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B nTnp = {\(aqNX_UINT64\(aq: \(aquint64\(aq, \(aqNX_UINT32\(aq: \(aquint32\(aq, \(aqNX_POSINT\(aq: \(aquint64\(aq, \(aqNX_UINT\(aq: \(aquint64\(aq, \(aqNX_NUMBER\(aq: \(aqfloat64\(aq, \(aqNX_UINT16\(aq: \(aquint16\(aq, \(aqNX_INT8\(aq: \(aqint8\(aq, \(aqNX_FLOAT32\(aq: \(aqfloat32\(aq, \(aqNX_FLOAT\(aq: \(aqfloat64\(aq, \(aqNX_INT32\(aq: \(aqint32\(aq, \(aqNX_INT16\(aq: \(aqint16\(aq, \(aqNX_UINT8\(aq: \(aquint8\(aq, \(aqNX_FLOAT64\(aq: \(aqfloat64\(aq, \(aqNX_CHAR\(aq: \(aqstring\(aq, \(aqNX_BOOLEAN\(aq: \(aqbool\(aq, \(aqNX_INT\(aq: \(aqint64\(aq, \(aqNX_DATE_TIME\(aq: \(aqstring\(aq, \(aqNX_INT64\(aq: \(aqint64\(aq, \(aqISO8601\(aq: \(aqstring\(aq}
map of NEXUS :  numpy types
.UNINDENT
.INDENT 7.0
.TP
.B npTt = {\(aquint64\(aq: \(aqDevULong64\(aq, \(aqint32\(aq: \(aqDevLong\(aq, \(aqint16\(aq: \(aqDevShort\(aq, \(aqstring\(aq: \(aqDevString\(aq, \(aqfloat64\(aq: \(aqDevDouble\(aq, \(aqint\(aq: \(aqDevLong64\(aq, \(aqfloat\(aq: \(aqDevDouble\(aq, \(aqbool\(aq: \(aqDevBoolean\(aq, \(aquint8\(aq: \(aqDevUChar\(aq, \(aquint32\(aq: \(aqDevULong\(aq, \(aquint16\(aq: \(aqDevUShort\(aq, \(aqint64\(aq: \(aqDevLong64\(aq, \(aquint\(aq: \(aqDevULong64\(aq, \(aqfloat16\(aq: \(aqDevFloat\(aq, \(aqint8\(aq: \(aqDevUChar\(aq, \(aqfloat32\(aq: \(aqDevFloat\(aq}
map of Numpy:Tango types
.UNINDENT
.INDENT 7.0
.TP
.B pTt = {\(aqstr\(aq: \(aqDevString\(aq, \(aqint\(aq: \(aqDevLong64\(aq, \(aqfloat\(aq: \(aqDevDouble\(aq, \(aqlong\(aq: \(aqDevLong64\(aq, \(aqbool\(aq: \(aqDevBoolean\(aq, \(aqunicode\(aq: \(aqDevString\(aq}
map of Python:Tango types
.UNINDENT
.INDENT 7.0
.TP
.B rTf = {0: \(aqSCALAR\(aq, 1: \(aqSPECTRUM\(aq, 2: \(aqIMAGE\(aq, 3: \(aqVERTEX\(aq}
map of rank :  data format
.UNINDENT
.UNINDENT
.SS Module contents
.sp
Tango Data Writer
.INDENT 0.0
.TP
.B nxswriter.run(argv)
launches the TANGO server
.INDENT 7.0
.TP
.B Parameters
\fBargv\fP \-\- command\-line arguments
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fIgenindex\fP
.IP \(bu 2
\fImodindex\fP
.IP \(bu 2
\fIsearch\fP
.UNINDENT
.SH AUTHOR
Author
.SH COPYRIGHT
2012-2016 DESY, Jan Kotanski <jkotan@mail.desy.de>

GNU GENERAL PUBLIC LICENSE, version 3
.\" Generated by docutils manpage writer.
.
